import json
from typing import Dict, List, Any, Optional

def load_dataset(filepath: str) -> List[Dict]:
    """Load dataset from JSON file"""
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)

def create_prompts(item: Dict) -> tuple:
    """Create both prompt templates for the given item"""
    
    # Extract necessary information
    question = item.get('question', '')
    original_text = item.get('original_answer', '')
    
    # Get advertisement info (use the first product from metadata)
    ad_metadata = item.get('ad_metadata', {})
    top_products = ad_metadata.get('top_products', [])
    
    if not top_products:
        return None, None
    
    # Use the first/top product for advertisement
    product = top_products[0]
    company_name = product.get('name', '')
    description = product.get('description', '')
    product_link = product.get('url', '')
    category = product.get('category', '')
    
    # Template 1: Simple prompt (worse quality)
    simple_prompt = f"""### Instruction:
Insert "{company_name} - {description}" into the following text naturally, adding only minimal extra words to make it flow well.
Text: {original_text}
### Response:"""

    # Template 2: Detailed prompt (better quality)
    detailed_prompt = f"""### Instruction:
You are a expert at marketing using native advertising. Your task is to seamlessly integrate an advertisement for a client's product into the body of an AI assistant's text response while maintaining the original context and flow. This response will be sent directly to the user of the AI assistant.
You will be given the name of the client's product, a description of that product, the URL of the product's web page, a general product category for that product, the prompt given to the AI assistant, and the response generated by the AI assistant.
The client's instructions, which you MUST abide by, are as follows:
- Do not remove any information from the response.
- Only an advertisement into the response in a single location.
- Avoid using the first person or first person possessive (i.e. no use of "I recommend", "our product").
- Do not include any purchase links in the edits.
- Make as few edits as possible.
- Ensure the advertisement fits naturally within the context of the response.
- Do not explicitly mention that the text is an advertisement or use the word "advertisement".
- Do not mention any retailers not explicitly mentioned in the description.
- Do not provide any explanation of the changes made.
- Ensure that the modified response still functions as a response to the prompt.
- Output the modified response with the advertisement included, without truncating, abbreviating, or annotating the original response.
- You must only use information provided directly by the client!
Product name: {company_name}
Description: {description}
URL: {product_link}
Category: {category}
Prompt: {question}
Text: {original_text}
### Response:"""

    return simple_prompt, detailed_prompt

def find_matching_item(target_item: Dict, dataset: List[Dict]) -> Optional[Dict]:
    """Find matching item in dataset based on question and original answer"""
    target_question = target_item.get('question', '').strip()
    target_original = target_item.get('original_answer', '').strip()
    
    for item in dataset:
        item_question = item.get('question', '').strip()
        item_original = item.get('original_answer', '').strip()
        
        # Match by question first (exact match)
        if item_question == target_question:
            return item
        
        # Fallback: match by original answer (exact match)
        if item_original == target_original:
            return item
    
    return None

def create_dpo_dataset(dataset1_path: str, dataset2_path: str, output_path: str):
    """
    Create DPO dataset by merging two datasets.
    """
    
    print("Loading datasets...")
    dataset1 = load_dataset(dataset1_path)  # Dataset 1
    dataset2 = load_dataset(dataset2_path)  # Dataset 2
    
    print(f"Dataset 1 size: {len(dataset1)}")
    print(f"Dataset 2 size: {len(dataset2)}")
    
    merged_pairs = []
    matched_count = 0
    skipped_count = 0
    
    print("Creating merged pairs...")
    
    for item2 in dataset2:  # Iterate through dataset 2
        # Find matching item in dataset 1
        matching_item1 = find_matching_item(item2, dataset1)
        
        if matching_item1 is None:
            print(f"No match found for question: {item2.get('question', '')[:50]}...")
            skipped_count += 1
            continue
        
        # Create prompts for this pair
        simple_prompt, detailed_prompt = create_prompts(item2)
        
        if simple_prompt is None or detailed_prompt is None:
            print(f"Could not create prompts for question: {item2.get('question', '')[:50]}...")
            skipped_count += 1
            continue
        
        # Create merged pair with empty preference field
        merged_pair = {
            "prompt": detailed_prompt,
            "response_1": matching_item1.get('answer', ''),  # Dataset 1 response
            "response_2": item2.get('answer', ''),  # Dataset 2 response
            "preference": "",  # Empty field for future annotation
            "metadata": {
                "question": item2.get('question', ''),
                "original_answer": item2.get('original_answer', ''),
                "simple_prompt": simple_prompt,
                "detailed_prompt": detailed_prompt,
                "response_1_ad_metadata": matching_item1.get('ad_metadata', {}),
                "response_2_ad_metadata": item2.get('ad_metadata', {}),
                "dataset1_model": matching_item1.get('model', ''),
                "dataset2_model": item2.get('model', '')
            }
        }
        
        merged_pairs.append(merged_pair)
        matched_count += 1
        
        if matched_count % 100 == 0:
            print(f"Processed {matched_count} pairs...")
    
    print(f"\nSummary:")
    print(f"Successfully matched pairs: {matched_count}")
    print(f"Skipped items: {skipped_count}")
    print(f"Total pairs created: {len(merged_pairs)}")
    
    # Save merged dataset
    print(f"Saving merged dataset to {output_path}...")
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(merged_pairs, f, ensure_ascii=False, indent=2)
    
    print("Done!")

if __name__ == "__main__":
    # Fi`le` paths - adjust these to your actual file locations
    dataset1_path = "wildchat_1k_filtered_ads_baseline.json"      # Dataset 1 
    dataset2_path = "wildchat_1k_filtered_ads_better_prompting.json"    # Dataset 2
    output_path = "dpo_ads_whildchat.json"
    
    # Create merged dataset
    create_dpo_dataset(dataset1_path, dataset2_path, output_path)